Name:  Justin Stevens
Files included:  tictacimage.c

For this project, I started with the code which I had for the 3 by 3 game of tictactoe from the previous project and modified it a lot.  To begin with, the first major modification I had to make was for the board to have dimensions 4 by 4 instead of 3 by 3, which was accomplished by changing all the parameters of the functions to char board[4][4].  Furthermore, I also had to update functions such as clear_table to go all the way to i<4 instead of i<3, and display_table to include the fourth row and column.  

Beyond these more minor changes, one major change I had to make was in the check_four_in_a_row function.  For this, I added the extra condition that we have to have board[row][3]==board[row][2] for all the items in a row to be the same, and board[col][3]==board[col][2] for all the items in a column to be the same.  Additionally, I had to modify the diagonal cases to check if the diagonals (0,0), (1,1), (2,2), (3,3) or (0,3), (1,2), (2,1), (3,0) were all the same.  The functions check_table_full and check_legal option were left the same.  

The display_image function was the hardest to write, because I had to use some old code from the image project in project 5 and make it into a 4 by 4 tic tac toe board.  To begin with, I noticed that the board size had to be 23 based on the sample provided in the project details.  Then, I figured out the cases were we wanted black lines to be the lines of the board.  As I found previously, if we set quotient to be the board size (which is 23) divided by 4, these conditions are met when row==quotient, row==2*quotient+1, but additionally we have to add the case row==3*quotient+2.  The reason for this is we want equal spacing between all of these black lines, and arrays begin at 0.  Similar conditions were added for the columns.

Now, I had to figure out how to fill in the now sectioned apart board.  I wanted a mapping that would take all the rows of the 23 by 23 grid and if the row was between 0 and quotient, it would give a board_row of 0 (which is the first row of the board the user entered), if it's between quotient and 2*quotient+1, it would give a board_row of 1 (which is the second row of the board), etc.  I thought of trying to find a mathematical function to do this, however, didn't succeed, therefore, I included a lot of if statements.  After I found this, I was able to hash into the right spot on the board using the board_row and board_col, which then told the computer which value to put in X (which is the 23 by 23 grid).  This was accomplished through a switch, where if it was blank, I made it white (255), if it was an X, I made it gray (128), and if it was an O,  made it a 0 (0).  

The final thing which I did was I had to modify how I accepted user input.  Previously, the user would just enter in two numbers (a row and a column), which would be put into variables through scanf("%d, %d", &row, &col);  However, now the user has a much wider range of possiblities, therefore, I declared a string move of size 4, which the user's input would be put into.  If the first element of this array was an integer, the program figures out that the user is entering a move, and gives the values row and col their respective values.  In the other cases for move[0], such as if the user entered 'c', 's', or 'p', call their respective functions.  

